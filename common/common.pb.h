// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto

#ifndef PROTOBUF_common_2eproto__INCLUDED
#define PROTOBUF_common_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace vipkid {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_common_2eproto();
void protobuf_AssignDesc_common_2eproto();
void protobuf_ShutdownFile_common_2eproto();

class RouteMsg;
class SSHead;
class AddRoomUser;
class AddRoomUserRsp;
class BroadCast;
class BroadCastRsp;
class CreateRoom;
class CreateRoomRsp;
class UserInfo;
class RoomInfo;
class GetRoomInfo;
class GetRoomInfoRsp;
class GetRoomList;
class GetRoomListRsp;
class KeepAlive;
class UniCast;

enum BroadCastMessageType {
  MSG_CHAT = 1,
  MSG_ENTER_ROOM = 2,
  MSG_LEAVE_ROOM = 3,
  MSG_STARTS = 4
};
bool BroadCastMessageType_IsValid(int value);
const BroadCastMessageType BroadCastMessageType_MIN = MSG_CHAT;
const BroadCastMessageType BroadCastMessageType_MAX = MSG_STARTS;
const int BroadCastMessageType_ARRAYSIZE = BroadCastMessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* BroadCastMessageType_descriptor();
inline const ::std::string& BroadCastMessageType_Name(BroadCastMessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    BroadCastMessageType_descriptor(), value);
}
inline bool BroadCastMessageType_Parse(
    const ::std::string& name, BroadCastMessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BroadCastMessageType>(
    BroadCastMessageType_descriptor(), name, value);
}
// ===================================================================

class RouteMsg : public ::google::protobuf::Message {
 public:
  RouteMsg();
  virtual ~RouteMsg();

  RouteMsg(const RouteMsg& from);

  inline RouteMsg& operator=(const RouteMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RouteMsg& default_instance();

  void Swap(RouteMsg* other);

  // implements Message ----------------------------------------------

  RouteMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RouteMsg& from);
  void MergeFrom(const RouteMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes rid = 1;
  inline bool has_rid() const;
  inline void clear_rid();
  static const int kRidFieldNumber = 1;
  inline const ::std::string& rid() const;
  inline void set_rid(const ::std::string& value);
  inline void set_rid(const char* value);
  inline void set_rid(const void* value, size_t size);
  inline ::std::string* mutable_rid();
  inline ::std::string* release_rid();
  inline void set_allocated_rid(::std::string* rid);

  // optional bytes uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const void* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional uint32 rtype = 3;
  inline bool has_rtype() const;
  inline void clear_rtype();
  static const int kRtypeFieldNumber = 3;
  inline ::google::protobuf::uint32 rtype() const;
  inline void set_rtype(::google::protobuf::uint32 value);

  // optional bytes msg = 4;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 4;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const void* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:vipkid.RouteMsg)
 private:
  inline void set_has_rid();
  inline void clear_has_rid();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_rtype();
  inline void clear_has_rtype();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* rid_;
  ::std::string* uid_;
  ::std::string* msg_;
  ::google::protobuf::uint32 rtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static RouteMsg* default_instance_;
};
// -------------------------------------------------------------------

class SSHead : public ::google::protobuf::Message {
 public:
  SSHead();
  virtual ~SSHead();

  SSHead(const SSHead& from);

  inline SSHead& operator=(const SSHead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SSHead& default_instance();

  void Swap(SSHead* other);

  // implements Message ----------------------------------------------

  SSHead* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SSHead& from);
  void MergeFrom(const SSHead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 command = 1;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline ::google::protobuf::uint32 command() const;
  inline void set_command(::google::protobuf::uint32 value);

  // optional bytes uuid = 2;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 2;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const void* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // optional uint32 client_ip = 3;
  inline bool has_client_ip() const;
  inline void clear_client_ip();
  static const int kClientIpFieldNumber = 3;
  inline ::google::protobuf::uint32 client_ip() const;
  inline void set_client_ip(::google::protobuf::uint32 value);

  // optional uint32 client_port = 4;
  inline bool has_client_port() const;
  inline void clear_client_port();
  static const int kClientPortFieldNumber = 4;
  inline ::google::protobuf::uint32 client_port() const;
  inline void set_client_port(::google::protobuf::uint32 value);

  // optional uint32 client_type = 5;
  inline bool has_client_type() const;
  inline void clear_client_type();
  static const int kClientTypeFieldNumber = 5;
  inline ::google::protobuf::uint32 client_type() const;
  inline void set_client_type(::google::protobuf::uint32 value);

  // optional uint32 upstream_type = 6;
  inline bool has_upstream_type() const;
  inline void clear_upstream_type();
  static const int kUpstreamTypeFieldNumber = 6;
  inline ::google::protobuf::uint32 upstream_type() const;
  inline void set_upstream_type(::google::protobuf::uint32 value);

  // optional uint32 objectid = 7;
  inline bool has_objectid() const;
  inline void clear_objectid();
  static const int kObjectidFieldNumber = 7;
  inline ::google::protobuf::uint32 objectid() const;
  inline void set_objectid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vipkid.SSHead)
 private:
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_client_ip();
  inline void clear_has_client_ip();
  inline void set_has_client_port();
  inline void clear_has_client_port();
  inline void set_has_client_type();
  inline void clear_has_client_type();
  inline void set_has_upstream_type();
  inline void clear_has_upstream_type();
  inline void set_has_objectid();
  inline void clear_has_objectid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uuid_;
  ::google::protobuf::uint32 command_;
  ::google::protobuf::uint32 client_ip_;
  ::google::protobuf::uint32 client_port_;
  ::google::protobuf::uint32 client_type_;
  ::google::protobuf::uint32 upstream_type_;
  ::google::protobuf::uint32 objectid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static SSHead* default_instance_;
};
// -------------------------------------------------------------------

class AddRoomUser : public ::google::protobuf::Message {
 public:
  AddRoomUser();
  virtual ~AddRoomUser();

  AddRoomUser(const AddRoomUser& from);

  inline AddRoomUser& operator=(const AddRoomUser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddRoomUser& default_instance();

  void Swap(AddRoomUser* other);

  // implements Message ----------------------------------------------

  AddRoomUser* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddRoomUser& from);
  void MergeFrom(const AddRoomUser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const void* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // optional bytes groupid = 2;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupidFieldNumber = 2;
  inline const ::std::string& groupid() const;
  inline void set_groupid(const ::std::string& value);
  inline void set_groupid(const char* value);
  inline void set_groupid(const void* value, size_t size);
  inline ::std::string* mutable_groupid();
  inline ::std::string* release_groupid();
  inline void set_allocated_groupid(::std::string* groupid);

  // optional bytes nick = 3;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 3;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const void* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  inline void set_allocated_nick(::std::string* nick);

  // @@protoc_insertion_point(class_scope:vipkid.AddRoomUser)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_nick();
  inline void clear_has_nick();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uuid_;
  ::std::string* groupid_;
  ::std::string* nick_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static AddRoomUser* default_instance_;
};
// -------------------------------------------------------------------

class AddRoomUserRsp : public ::google::protobuf::Message {
 public:
  AddRoomUserRsp();
  virtual ~AddRoomUserRsp();

  AddRoomUserRsp(const AddRoomUserRsp& from);

  inline AddRoomUserRsp& operator=(const AddRoomUserRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddRoomUserRsp& default_instance();

  void Swap(AddRoomUserRsp* other);

  // implements Message ----------------------------------------------

  AddRoomUserRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddRoomUserRsp& from);
  void MergeFrom(const AddRoomUserRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vipkid.AddRoomUserRsp)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static AddRoomUserRsp* default_instance_;
};
// -------------------------------------------------------------------

class BroadCast : public ::google::protobuf::Message {
 public:
  BroadCast();
  virtual ~BroadCast();

  BroadCast(const BroadCast& from);

  inline BroadCast& operator=(const BroadCast& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BroadCast& default_instance();

  void Swap(BroadCast* other);

  // implements Message ----------------------------------------------

  BroadCast* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BroadCast& from);
  void MergeFrom(const BroadCast& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const void* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // optional bytes groupid = 2;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupidFieldNumber = 2;
  inline const ::std::string& groupid() const;
  inline void set_groupid(const ::std::string& value);
  inline void set_groupid(const char* value);
  inline void set_groupid(const void* value, size_t size);
  inline ::std::string* mutable_groupid();
  inline ::std::string* release_groupid();
  inline void set_allocated_groupid(::std::string* groupid);

  // optional uint32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional bytes msg = 4;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 4;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const void* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // optional bytes nick = 5;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 5;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const void* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  inline void set_allocated_nick(::std::string* nick);

  // @@protoc_insertion_point(class_scope:vipkid.BroadCast)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_nick();
  inline void clear_has_nick();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uuid_;
  ::std::string* groupid_;
  ::std::string* msg_;
  ::std::string* nick_;
  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static BroadCast* default_instance_;
};
// -------------------------------------------------------------------

class BroadCastRsp : public ::google::protobuf::Message {
 public:
  BroadCastRsp();
  virtual ~BroadCastRsp();

  BroadCastRsp(const BroadCastRsp& from);

  inline BroadCastRsp& operator=(const BroadCastRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BroadCastRsp& default_instance();

  void Swap(BroadCastRsp* other);

  // implements Message ----------------------------------------------

  BroadCastRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BroadCastRsp& from);
  void MergeFrom(const BroadCastRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vipkid.BroadCastRsp)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static BroadCastRsp* default_instance_;
};
// -------------------------------------------------------------------

class CreateRoom : public ::google::protobuf::Message {
 public:
  CreateRoom();
  virtual ~CreateRoom();

  CreateRoom(const CreateRoom& from);

  inline CreateRoom& operator=(const CreateRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRoom& default_instance();

  void Swap(CreateRoom* other);

  // implements Message ----------------------------------------------

  CreateRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateRoom& from);
  void MergeFrom(const CreateRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const void* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // optional bytes groupid = 2;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupidFieldNumber = 2;
  inline const ::std::string& groupid() const;
  inline void set_groupid(const ::std::string& value);
  inline void set_groupid(const char* value);
  inline void set_groupid(const void* value, size_t size);
  inline ::std::string* mutable_groupid();
  inline ::std::string* release_groupid();
  inline void set_allocated_groupid(::std::string* groupid);

  // @@protoc_insertion_point(class_scope:vipkid.CreateRoom)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_groupid();
  inline void clear_has_groupid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uuid_;
  ::std::string* groupid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static CreateRoom* default_instance_;
};
// -------------------------------------------------------------------

class CreateRoomRsp : public ::google::protobuf::Message {
 public:
  CreateRoomRsp();
  virtual ~CreateRoomRsp();

  CreateRoomRsp(const CreateRoomRsp& from);

  inline CreateRoomRsp& operator=(const CreateRoomRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRoomRsp& default_instance();

  void Swap(CreateRoomRsp* other);

  // implements Message ----------------------------------------------

  CreateRoomRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateRoomRsp& from);
  void MergeFrom(const CreateRoomRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vipkid.CreateRoomRsp)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static CreateRoomRsp* default_instance_;
};
// -------------------------------------------------------------------

class UserInfo : public ::google::protobuf::Message {
 public:
  UserInfo();
  virtual ~UserInfo();

  UserInfo(const UserInfo& from);

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfo& default_instance();

  void Swap(UserInfo* other);

  // implements Message ----------------------------------------------

  UserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const void* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // optional bytes nick = 2;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 2;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const void* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  inline void set_allocated_nick(::std::string* nick);

  // optional uint32 role = 3;
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 3;
  inline ::google::protobuf::uint32 role() const;
  inline void set_role(::google::protobuf::uint32 value);

  // optional uint32 star_num = 4;
  inline bool has_star_num() const;
  inline void clear_star_num();
  static const int kStarNumFieldNumber = 4;
  inline ::google::protobuf::uint32 star_num() const;
  inline void set_star_num(::google::protobuf::uint32 value);

  // optional bytes conn_addr = 5;
  inline bool has_conn_addr() const;
  inline void clear_conn_addr();
  static const int kConnAddrFieldNumber = 5;
  inline const ::std::string& conn_addr() const;
  inline void set_conn_addr(const ::std::string& value);
  inline void set_conn_addr(const char* value);
  inline void set_conn_addr(const void* value, size_t size);
  inline ::std::string* mutable_conn_addr();
  inline ::std::string* release_conn_addr();
  inline void set_allocated_conn_addr(::std::string* conn_addr);

  // optional uint32 conn_port = 6;
  inline bool has_conn_port() const;
  inline void clear_conn_port();
  static const int kConnPortFieldNumber = 6;
  inline ::google::protobuf::uint32 conn_port() const;
  inline void set_conn_port(::google::protobuf::uint32 value);

  // optional bytes roomid = 7;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 7;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const void* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // @@protoc_insertion_point(class_scope:vipkid.UserInfo)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_nick();
  inline void clear_has_nick();
  inline void set_has_role();
  inline void clear_has_role();
  inline void set_has_star_num();
  inline void clear_has_star_num();
  inline void set_has_conn_addr();
  inline void clear_has_conn_addr();
  inline void set_has_conn_port();
  inline void clear_has_conn_port();
  inline void set_has_roomid();
  inline void clear_has_roomid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uuid_;
  ::std::string* nick_;
  ::google::protobuf::uint32 role_;
  ::google::protobuf::uint32 star_num_;
  ::std::string* conn_addr_;
  ::std::string* roomid_;
  ::google::protobuf::uint32 conn_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static UserInfo* default_instance_;
};
// -------------------------------------------------------------------

class RoomInfo : public ::google::protobuf::Message {
 public:
  RoomInfo();
  virtual ~RoomInfo();

  RoomInfo(const RoomInfo& from);

  inline RoomInfo& operator=(const RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomInfo& default_instance();

  void Swap(RoomInfo* other);

  // implements Message ----------------------------------------------

  RoomInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomInfo& from);
  void MergeFrom(const RoomInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes creator_uuid = 1;
  inline bool has_creator_uuid() const;
  inline void clear_creator_uuid();
  static const int kCreatorUuidFieldNumber = 1;
  inline const ::std::string& creator_uuid() const;
  inline void set_creator_uuid(const ::std::string& value);
  inline void set_creator_uuid(const char* value);
  inline void set_creator_uuid(const void* value, size_t size);
  inline ::std::string* mutable_creator_uuid();
  inline ::std::string* release_creator_uuid();
  inline void set_allocated_creator_uuid(::std::string* creator_uuid);

  // optional bytes groupid = 2;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupidFieldNumber = 2;
  inline const ::std::string& groupid() const;
  inline void set_groupid(const ::std::string& value);
  inline void set_groupid(const char* value);
  inline void set_groupid(const void* value, size_t size);
  inline ::std::string* mutable_groupid();
  inline ::std::string* release_groupid();
  inline void set_allocated_groupid(::std::string* groupid);

  // optional uint32 createtime = 3;
  inline bool has_createtime() const;
  inline void clear_createtime();
  static const int kCreatetimeFieldNumber = 3;
  inline ::google::protobuf::uint32 createtime() const;
  inline void set_createtime(::google::protobuf::uint32 value);

  // repeated .vipkid.UserInfo user_list = 4;
  inline int user_list_size() const;
  inline void clear_user_list();
  static const int kUserListFieldNumber = 4;
  inline const ::vipkid::UserInfo& user_list(int index) const;
  inline ::vipkid::UserInfo* mutable_user_list(int index);
  inline ::vipkid::UserInfo* add_user_list();
  inline const ::google::protobuf::RepeatedPtrField< ::vipkid::UserInfo >&
      user_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::vipkid::UserInfo >*
      mutable_user_list();

  // optional uint32 ppt_page = 5;
  inline bool has_ppt_page() const;
  inline void clear_ppt_page();
  static const int kPptPageFieldNumber = 5;
  inline ::google::protobuf::uint32 ppt_page() const;
  inline void set_ppt_page(::google::protobuf::uint32 value);

  // optional bytes board_data = 6;
  inline bool has_board_data() const;
  inline void clear_board_data();
  static const int kBoardDataFieldNumber = 6;
  inline const ::std::string& board_data() const;
  inline void set_board_data(const ::std::string& value);
  inline void set_board_data(const char* value);
  inline void set_board_data(const void* value, size_t size);
  inline ::std::string* mutable_board_data();
  inline ::std::string* release_board_data();
  inline void set_allocated_board_data(::std::string* board_data);

  // optional uint32 user_num = 7;
  inline bool has_user_num() const;
  inline void clear_user_num();
  static const int kUserNumFieldNumber = 7;
  inline ::google::protobuf::uint32 user_num() const;
  inline void set_user_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vipkid.RoomInfo)
 private:
  inline void set_has_creator_uuid();
  inline void clear_has_creator_uuid();
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_createtime();
  inline void clear_has_createtime();
  inline void set_has_ppt_page();
  inline void clear_has_ppt_page();
  inline void set_has_board_data();
  inline void clear_has_board_data();
  inline void set_has_user_num();
  inline void clear_has_user_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* creator_uuid_;
  ::std::string* groupid_;
  ::google::protobuf::RepeatedPtrField< ::vipkid::UserInfo > user_list_;
  ::google::protobuf::uint32 createtime_;
  ::google::protobuf::uint32 ppt_page_;
  ::std::string* board_data_;
  ::google::protobuf::uint32 user_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static RoomInfo* default_instance_;
};
// -------------------------------------------------------------------

class GetRoomInfo : public ::google::protobuf::Message {
 public:
  GetRoomInfo();
  virtual ~GetRoomInfo();

  GetRoomInfo(const GetRoomInfo& from);

  inline GetRoomInfo& operator=(const GetRoomInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRoomInfo& default_instance();

  void Swap(GetRoomInfo* other);

  // implements Message ----------------------------------------------

  GetRoomInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetRoomInfo& from);
  void MergeFrom(const GetRoomInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const void* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // optional bytes groupid = 2;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupidFieldNumber = 2;
  inline const ::std::string& groupid() const;
  inline void set_groupid(const ::std::string& value);
  inline void set_groupid(const char* value);
  inline void set_groupid(const void* value, size_t size);
  inline ::std::string* mutable_groupid();
  inline ::std::string* release_groupid();
  inline void set_allocated_groupid(::std::string* groupid);

  // @@protoc_insertion_point(class_scope:vipkid.GetRoomInfo)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_groupid();
  inline void clear_has_groupid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uuid_;
  ::std::string* groupid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static GetRoomInfo* default_instance_;
};
// -------------------------------------------------------------------

class GetRoomInfoRsp : public ::google::protobuf::Message {
 public:
  GetRoomInfoRsp();
  virtual ~GetRoomInfoRsp();

  GetRoomInfoRsp(const GetRoomInfoRsp& from);

  inline GetRoomInfoRsp& operator=(const GetRoomInfoRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRoomInfoRsp& default_instance();

  void Swap(GetRoomInfoRsp* other);

  // implements Message ----------------------------------------------

  GetRoomInfoRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetRoomInfoRsp& from);
  void MergeFrom(const GetRoomInfoRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // optional .vipkid.RoomInfo info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::vipkid::RoomInfo& info() const;
  inline ::vipkid::RoomInfo* mutable_info();
  inline ::vipkid::RoomInfo* release_info();
  inline void set_allocated_info(::vipkid::RoomInfo* info);

  // @@protoc_insertion_point(class_scope:vipkid.GetRoomInfoRsp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::vipkid::RoomInfo* info_;
  ::google::protobuf::uint32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static GetRoomInfoRsp* default_instance_;
};
// -------------------------------------------------------------------

class GetRoomList : public ::google::protobuf::Message {
 public:
  GetRoomList();
  virtual ~GetRoomList();

  GetRoomList(const GetRoomList& from);

  inline GetRoomList& operator=(const GetRoomList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRoomList& default_instance();

  void Swap(GetRoomList* other);

  // implements Message ----------------------------------------------

  GetRoomList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetRoomList& from);
  void MergeFrom(const GetRoomList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const void* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // @@protoc_insertion_point(class_scope:vipkid.GetRoomList)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static GetRoomList* default_instance_;
};
// -------------------------------------------------------------------

class GetRoomListRsp : public ::google::protobuf::Message {
 public:
  GetRoomListRsp();
  virtual ~GetRoomListRsp();

  GetRoomListRsp(const GetRoomListRsp& from);

  inline GetRoomListRsp& operator=(const GetRoomListRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRoomListRsp& default_instance();

  void Swap(GetRoomListRsp* other);

  // implements Message ----------------------------------------------

  GetRoomListRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetRoomListRsp& from);
  void MergeFrom(const GetRoomListRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // repeated .vipkid.RoomInfo list = 2;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 2;
  inline const ::vipkid::RoomInfo& list(int index) const;
  inline ::vipkid::RoomInfo* mutable_list(int index);
  inline ::vipkid::RoomInfo* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::vipkid::RoomInfo >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::vipkid::RoomInfo >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:vipkid.GetRoomListRsp)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::vipkid::RoomInfo > list_;
  ::google::protobuf::uint32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static GetRoomListRsp* default_instance_;
};
// -------------------------------------------------------------------

class KeepAlive : public ::google::protobuf::Message {
 public:
  KeepAlive();
  virtual ~KeepAlive();

  KeepAlive(const KeepAlive& from);

  inline KeepAlive& operator=(const KeepAlive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeepAlive& default_instance();

  void Swap(KeepAlive* other);

  // implements Message ----------------------------------------------

  KeepAlive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeepAlive& from);
  void MergeFrom(const KeepAlive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const void* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // optional bytes groupid = 2;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupidFieldNumber = 2;
  inline const ::std::string& groupid() const;
  inline void set_groupid(const ::std::string& value);
  inline void set_groupid(const char* value);
  inline void set_groupid(const void* value, size_t size);
  inline ::std::string* mutable_groupid();
  inline ::std::string* release_groupid();
  inline void set_allocated_groupid(::std::string* groupid);

  // @@protoc_insertion_point(class_scope:vipkid.KeepAlive)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_groupid();
  inline void clear_has_groupid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uuid_;
  ::std::string* groupid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static KeepAlive* default_instance_;
};
// -------------------------------------------------------------------

class UniCast : public ::google::protobuf::Message {
 public:
  UniCast();
  virtual ~UniCast();

  UniCast(const UniCast& from);

  inline UniCast& operator=(const UniCast& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UniCast& default_instance();

  void Swap(UniCast* other);

  // implements Message ----------------------------------------------

  UniCast* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UniCast& from);
  void MergeFrom(const UniCast& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const void* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // optional bytes groupid = 2;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupidFieldNumber = 2;
  inline const ::std::string& groupid() const;
  inline void set_groupid(const ::std::string& value);
  inline void set_groupid(const char* value);
  inline void set_groupid(const void* value, size_t size);
  inline ::std::string* mutable_groupid();
  inline ::std::string* release_groupid();
  inline void set_allocated_groupid(::std::string* groupid);

  // optional bytes to_uuid = 3;
  inline bool has_to_uuid() const;
  inline void clear_to_uuid();
  static const int kToUuidFieldNumber = 3;
  inline const ::std::string& to_uuid() const;
  inline void set_to_uuid(const ::std::string& value);
  inline void set_to_uuid(const char* value);
  inline void set_to_uuid(const void* value, size_t size);
  inline ::std::string* mutable_to_uuid();
  inline ::std::string* release_to_uuid();
  inline void set_allocated_to_uuid(::std::string* to_uuid);

  // optional bytes msg = 4;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 4;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const void* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // optional bytes nick = 5;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 5;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const void* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  inline void set_allocated_nick(::std::string* nick);

  // @@protoc_insertion_point(class_scope:vipkid.UniCast)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_to_uuid();
  inline void clear_has_to_uuid();
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_nick();
  inline void clear_has_nick();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uuid_;
  ::std::string* groupid_;
  ::std::string* to_uuid_;
  ::std::string* msg_;
  ::std::string* nick_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static UniCast* default_instance_;
};
// ===================================================================


// ===================================================================

// RouteMsg

// optional bytes rid = 1;
inline bool RouteMsg::has_rid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RouteMsg::set_has_rid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RouteMsg::clear_has_rid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RouteMsg::clear_rid() {
  if (rid_ != &::google::protobuf::internal::kEmptyString) {
    rid_->clear();
  }
  clear_has_rid();
}
inline const ::std::string& RouteMsg::rid() const {
  return *rid_;
}
inline void RouteMsg::set_rid(const ::std::string& value) {
  set_has_rid();
  if (rid_ == &::google::protobuf::internal::kEmptyString) {
    rid_ = new ::std::string;
  }
  rid_->assign(value);
}
inline void RouteMsg::set_rid(const char* value) {
  set_has_rid();
  if (rid_ == &::google::protobuf::internal::kEmptyString) {
    rid_ = new ::std::string;
  }
  rid_->assign(value);
}
inline void RouteMsg::set_rid(const void* value, size_t size) {
  set_has_rid();
  if (rid_ == &::google::protobuf::internal::kEmptyString) {
    rid_ = new ::std::string;
  }
  rid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RouteMsg::mutable_rid() {
  set_has_rid();
  if (rid_ == &::google::protobuf::internal::kEmptyString) {
    rid_ = new ::std::string;
  }
  return rid_;
}
inline ::std::string* RouteMsg::release_rid() {
  clear_has_rid();
  if (rid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rid_;
    rid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RouteMsg::set_allocated_rid(::std::string* rid) {
  if (rid_ != &::google::protobuf::internal::kEmptyString) {
    delete rid_;
  }
  if (rid) {
    set_has_rid();
    rid_ = rid;
  } else {
    clear_has_rid();
    rid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes uid = 2;
inline bool RouteMsg::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RouteMsg::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RouteMsg::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RouteMsg::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& RouteMsg::uid() const {
  return *uid_;
}
inline void RouteMsg::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RouteMsg::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RouteMsg::set_uid(const void* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RouteMsg::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* RouteMsg::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RouteMsg::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 rtype = 3;
inline bool RouteMsg::has_rtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RouteMsg::set_has_rtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RouteMsg::clear_has_rtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RouteMsg::clear_rtype() {
  rtype_ = 0u;
  clear_has_rtype();
}
inline ::google::protobuf::uint32 RouteMsg::rtype() const {
  return rtype_;
}
inline void RouteMsg::set_rtype(::google::protobuf::uint32 value) {
  set_has_rtype();
  rtype_ = value;
}

// optional bytes msg = 4;
inline bool RouteMsg::has_msg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RouteMsg::set_has_msg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RouteMsg::clear_has_msg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RouteMsg::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& RouteMsg::msg() const {
  return *msg_;
}
inline void RouteMsg::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void RouteMsg::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void RouteMsg::set_msg(const void* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RouteMsg::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* RouteMsg::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RouteMsg::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SSHead

// optional uint32 command = 1;
inline bool SSHead::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SSHead::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SSHead::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SSHead::clear_command() {
  command_ = 0u;
  clear_has_command();
}
inline ::google::protobuf::uint32 SSHead::command() const {
  return command_;
}
inline void SSHead::set_command(::google::protobuf::uint32 value) {
  set_has_command();
  command_ = value;
}

// optional bytes uuid = 2;
inline bool SSHead::has_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SSHead::set_has_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SSHead::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SSHead::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& SSHead::uuid() const {
  return *uuid_;
}
inline void SSHead::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void SSHead::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void SSHead::set_uuid(const void* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SSHead::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* SSHead::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SSHead::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 client_ip = 3;
inline bool SSHead::has_client_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SSHead::set_has_client_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SSHead::clear_has_client_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SSHead::clear_client_ip() {
  client_ip_ = 0u;
  clear_has_client_ip();
}
inline ::google::protobuf::uint32 SSHead::client_ip() const {
  return client_ip_;
}
inline void SSHead::set_client_ip(::google::protobuf::uint32 value) {
  set_has_client_ip();
  client_ip_ = value;
}

// optional uint32 client_port = 4;
inline bool SSHead::has_client_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SSHead::set_has_client_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SSHead::clear_has_client_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SSHead::clear_client_port() {
  client_port_ = 0u;
  clear_has_client_port();
}
inline ::google::protobuf::uint32 SSHead::client_port() const {
  return client_port_;
}
inline void SSHead::set_client_port(::google::protobuf::uint32 value) {
  set_has_client_port();
  client_port_ = value;
}

// optional uint32 client_type = 5;
inline bool SSHead::has_client_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SSHead::set_has_client_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SSHead::clear_has_client_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SSHead::clear_client_type() {
  client_type_ = 0u;
  clear_has_client_type();
}
inline ::google::protobuf::uint32 SSHead::client_type() const {
  return client_type_;
}
inline void SSHead::set_client_type(::google::protobuf::uint32 value) {
  set_has_client_type();
  client_type_ = value;
}

// optional uint32 upstream_type = 6;
inline bool SSHead::has_upstream_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SSHead::set_has_upstream_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SSHead::clear_has_upstream_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SSHead::clear_upstream_type() {
  upstream_type_ = 0u;
  clear_has_upstream_type();
}
inline ::google::protobuf::uint32 SSHead::upstream_type() const {
  return upstream_type_;
}
inline void SSHead::set_upstream_type(::google::protobuf::uint32 value) {
  set_has_upstream_type();
  upstream_type_ = value;
}

// optional uint32 objectid = 7;
inline bool SSHead::has_objectid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SSHead::set_has_objectid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SSHead::clear_has_objectid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SSHead::clear_objectid() {
  objectid_ = 0u;
  clear_has_objectid();
}
inline ::google::protobuf::uint32 SSHead::objectid() const {
  return objectid_;
}
inline void SSHead::set_objectid(::google::protobuf::uint32 value) {
  set_has_objectid();
  objectid_ = value;
}

// -------------------------------------------------------------------

// AddRoomUser

// optional bytes uuid = 1;
inline bool AddRoomUser::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddRoomUser::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddRoomUser::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddRoomUser::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& AddRoomUser::uuid() const {
  return *uuid_;
}
inline void AddRoomUser::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void AddRoomUser::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void AddRoomUser::set_uuid(const void* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddRoomUser::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* AddRoomUser::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AddRoomUser::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes groupid = 2;
inline bool AddRoomUser::has_groupid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddRoomUser::set_has_groupid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddRoomUser::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddRoomUser::clear_groupid() {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    groupid_->clear();
  }
  clear_has_groupid();
}
inline const ::std::string& AddRoomUser::groupid() const {
  return *groupid_;
}
inline void AddRoomUser::set_groupid(const ::std::string& value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void AddRoomUser::set_groupid(const char* value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void AddRoomUser::set_groupid(const void* value, size_t size) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddRoomUser::mutable_groupid() {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  return groupid_;
}
inline ::std::string* AddRoomUser::release_groupid() {
  clear_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupid_;
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AddRoomUser::set_allocated_groupid(::std::string* groupid) {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    delete groupid_;
  }
  if (groupid) {
    set_has_groupid();
    groupid_ = groupid;
  } else {
    clear_has_groupid();
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes nick = 3;
inline bool AddRoomUser::has_nick() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddRoomUser::set_has_nick() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddRoomUser::clear_has_nick() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddRoomUser::clear_nick() {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    nick_->clear();
  }
  clear_has_nick();
}
inline const ::std::string& AddRoomUser::nick() const {
  return *nick_;
}
inline void AddRoomUser::set_nick(const ::std::string& value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void AddRoomUser::set_nick(const char* value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void AddRoomUser::set_nick(const void* value, size_t size) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddRoomUser::mutable_nick() {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  return nick_;
}
inline ::std::string* AddRoomUser::release_nick() {
  clear_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_;
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AddRoomUser::set_allocated_nick(::std::string* nick) {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_;
  }
  if (nick) {
    set_has_nick();
    nick_ = nick;
  } else {
    clear_has_nick();
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AddRoomUserRsp

// optional uint32 result = 1;
inline bool AddRoomUserRsp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddRoomUserRsp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddRoomUserRsp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddRoomUserRsp::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 AddRoomUserRsp::result() const {
  return result_;
}
inline void AddRoomUserRsp::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// BroadCast

// optional bytes uuid = 1;
inline bool BroadCast::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BroadCast::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BroadCast::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BroadCast::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& BroadCast::uuid() const {
  return *uuid_;
}
inline void BroadCast::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void BroadCast::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void BroadCast::set_uuid(const void* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BroadCast::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* BroadCast::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BroadCast::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes groupid = 2;
inline bool BroadCast::has_groupid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BroadCast::set_has_groupid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BroadCast::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BroadCast::clear_groupid() {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    groupid_->clear();
  }
  clear_has_groupid();
}
inline const ::std::string& BroadCast::groupid() const {
  return *groupid_;
}
inline void BroadCast::set_groupid(const ::std::string& value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void BroadCast::set_groupid(const char* value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void BroadCast::set_groupid(const void* value, size_t size) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BroadCast::mutable_groupid() {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  return groupid_;
}
inline ::std::string* BroadCast::release_groupid() {
  clear_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupid_;
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BroadCast::set_allocated_groupid(::std::string* groupid) {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    delete groupid_;
  }
  if (groupid) {
    set_has_groupid();
    groupid_ = groupid;
  } else {
    clear_has_groupid();
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 type = 3;
inline bool BroadCast::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BroadCast::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BroadCast::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BroadCast::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 BroadCast::type() const {
  return type_;
}
inline void BroadCast::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional bytes msg = 4;
inline bool BroadCast::has_msg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BroadCast::set_has_msg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BroadCast::clear_has_msg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BroadCast::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& BroadCast::msg() const {
  return *msg_;
}
inline void BroadCast::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void BroadCast::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void BroadCast::set_msg(const void* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BroadCast::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* BroadCast::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BroadCast::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes nick = 5;
inline bool BroadCast::has_nick() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BroadCast::set_has_nick() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BroadCast::clear_has_nick() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BroadCast::clear_nick() {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    nick_->clear();
  }
  clear_has_nick();
}
inline const ::std::string& BroadCast::nick() const {
  return *nick_;
}
inline void BroadCast::set_nick(const ::std::string& value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void BroadCast::set_nick(const char* value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void BroadCast::set_nick(const void* value, size_t size) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BroadCast::mutable_nick() {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  return nick_;
}
inline ::std::string* BroadCast::release_nick() {
  clear_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_;
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BroadCast::set_allocated_nick(::std::string* nick) {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_;
  }
  if (nick) {
    set_has_nick();
    nick_ = nick;
  } else {
    clear_has_nick();
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BroadCastRsp

// optional uint32 result = 1;
inline bool BroadCastRsp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BroadCastRsp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BroadCastRsp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BroadCastRsp::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 BroadCastRsp::result() const {
  return result_;
}
inline void BroadCastRsp::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// CreateRoom

// optional bytes uuid = 1;
inline bool CreateRoom::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoom::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRoom::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRoom::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& CreateRoom::uuid() const {
  return *uuid_;
}
inline void CreateRoom::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void CreateRoom::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void CreateRoom::set_uuid(const void* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateRoom::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* CreateRoom::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateRoom::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes groupid = 2;
inline bool CreateRoom::has_groupid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateRoom::set_has_groupid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateRoom::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateRoom::clear_groupid() {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    groupid_->clear();
  }
  clear_has_groupid();
}
inline const ::std::string& CreateRoom::groupid() const {
  return *groupid_;
}
inline void CreateRoom::set_groupid(const ::std::string& value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void CreateRoom::set_groupid(const char* value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void CreateRoom::set_groupid(const void* value, size_t size) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateRoom::mutable_groupid() {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  return groupid_;
}
inline ::std::string* CreateRoom::release_groupid() {
  clear_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupid_;
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateRoom::set_allocated_groupid(::std::string* groupid) {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    delete groupid_;
  }
  if (groupid) {
    set_has_groupid();
    groupid_ = groupid;
  } else {
    clear_has_groupid();
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CreateRoomRsp

// optional uint32 result = 1;
inline bool CreateRoomRsp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoomRsp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRoomRsp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRoomRsp::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 CreateRoomRsp::result() const {
  return result_;
}
inline void CreateRoomRsp::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// UserInfo

// optional bytes uuid = 1;
inline bool UserInfo::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& UserInfo::uuid() const {
  return *uuid_;
}
inline void UserInfo::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void UserInfo::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void UserInfo::set_uuid(const void* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* UserInfo::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfo::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes nick = 2;
inline bool UserInfo::has_nick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo::set_has_nick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo::clear_has_nick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo::clear_nick() {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    nick_->clear();
  }
  clear_has_nick();
}
inline const ::std::string& UserInfo::nick() const {
  return *nick_;
}
inline void UserInfo::set_nick(const ::std::string& value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void UserInfo::set_nick(const char* value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void UserInfo::set_nick(const void* value, size_t size) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_nick() {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  return nick_;
}
inline ::std::string* UserInfo::release_nick() {
  clear_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_;
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfo::set_allocated_nick(::std::string* nick) {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_;
  }
  if (nick) {
    set_has_nick();
    nick_ = nick;
  } else {
    clear_has_nick();
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 role = 3;
inline bool UserInfo::has_role() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfo::set_has_role() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfo::clear_has_role() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfo::clear_role() {
  role_ = 0u;
  clear_has_role();
}
inline ::google::protobuf::uint32 UserInfo::role() const {
  return role_;
}
inline void UserInfo::set_role(::google::protobuf::uint32 value) {
  set_has_role();
  role_ = value;
}

// optional uint32 star_num = 4;
inline bool UserInfo::has_star_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInfo::set_has_star_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInfo::clear_has_star_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInfo::clear_star_num() {
  star_num_ = 0u;
  clear_has_star_num();
}
inline ::google::protobuf::uint32 UserInfo::star_num() const {
  return star_num_;
}
inline void UserInfo::set_star_num(::google::protobuf::uint32 value) {
  set_has_star_num();
  star_num_ = value;
}

// optional bytes conn_addr = 5;
inline bool UserInfo::has_conn_addr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserInfo::set_has_conn_addr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserInfo::clear_has_conn_addr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserInfo::clear_conn_addr() {
  if (conn_addr_ != &::google::protobuf::internal::kEmptyString) {
    conn_addr_->clear();
  }
  clear_has_conn_addr();
}
inline const ::std::string& UserInfo::conn_addr() const {
  return *conn_addr_;
}
inline void UserInfo::set_conn_addr(const ::std::string& value) {
  set_has_conn_addr();
  if (conn_addr_ == &::google::protobuf::internal::kEmptyString) {
    conn_addr_ = new ::std::string;
  }
  conn_addr_->assign(value);
}
inline void UserInfo::set_conn_addr(const char* value) {
  set_has_conn_addr();
  if (conn_addr_ == &::google::protobuf::internal::kEmptyString) {
    conn_addr_ = new ::std::string;
  }
  conn_addr_->assign(value);
}
inline void UserInfo::set_conn_addr(const void* value, size_t size) {
  set_has_conn_addr();
  if (conn_addr_ == &::google::protobuf::internal::kEmptyString) {
    conn_addr_ = new ::std::string;
  }
  conn_addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_conn_addr() {
  set_has_conn_addr();
  if (conn_addr_ == &::google::protobuf::internal::kEmptyString) {
    conn_addr_ = new ::std::string;
  }
  return conn_addr_;
}
inline ::std::string* UserInfo::release_conn_addr() {
  clear_has_conn_addr();
  if (conn_addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = conn_addr_;
    conn_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfo::set_allocated_conn_addr(::std::string* conn_addr) {
  if (conn_addr_ != &::google::protobuf::internal::kEmptyString) {
    delete conn_addr_;
  }
  if (conn_addr) {
    set_has_conn_addr();
    conn_addr_ = conn_addr;
  } else {
    clear_has_conn_addr();
    conn_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 conn_port = 6;
inline bool UserInfo::has_conn_port() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserInfo::set_has_conn_port() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserInfo::clear_has_conn_port() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserInfo::clear_conn_port() {
  conn_port_ = 0u;
  clear_has_conn_port();
}
inline ::google::protobuf::uint32 UserInfo::conn_port() const {
  return conn_port_;
}
inline void UserInfo::set_conn_port(::google::protobuf::uint32 value) {
  set_has_conn_port();
  conn_port_ = value;
}

// optional bytes roomid = 7;
inline bool UserInfo::has_roomid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserInfo::set_has_roomid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserInfo::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserInfo::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& UserInfo::roomid() const {
  return *roomid_;
}
inline void UserInfo::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void UserInfo::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void UserInfo::set_roomid(const void* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* UserInfo::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfo::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RoomInfo

// optional bytes creator_uuid = 1;
inline bool RoomInfo::has_creator_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomInfo::set_has_creator_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomInfo::clear_has_creator_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomInfo::clear_creator_uuid() {
  if (creator_uuid_ != &::google::protobuf::internal::kEmptyString) {
    creator_uuid_->clear();
  }
  clear_has_creator_uuid();
}
inline const ::std::string& RoomInfo::creator_uuid() const {
  return *creator_uuid_;
}
inline void RoomInfo::set_creator_uuid(const ::std::string& value) {
  set_has_creator_uuid();
  if (creator_uuid_ == &::google::protobuf::internal::kEmptyString) {
    creator_uuid_ = new ::std::string;
  }
  creator_uuid_->assign(value);
}
inline void RoomInfo::set_creator_uuid(const char* value) {
  set_has_creator_uuid();
  if (creator_uuid_ == &::google::protobuf::internal::kEmptyString) {
    creator_uuid_ = new ::std::string;
  }
  creator_uuid_->assign(value);
}
inline void RoomInfo::set_creator_uuid(const void* value, size_t size) {
  set_has_creator_uuid();
  if (creator_uuid_ == &::google::protobuf::internal::kEmptyString) {
    creator_uuid_ = new ::std::string;
  }
  creator_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomInfo::mutable_creator_uuid() {
  set_has_creator_uuid();
  if (creator_uuid_ == &::google::protobuf::internal::kEmptyString) {
    creator_uuid_ = new ::std::string;
  }
  return creator_uuid_;
}
inline ::std::string* RoomInfo::release_creator_uuid() {
  clear_has_creator_uuid();
  if (creator_uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = creator_uuid_;
    creator_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomInfo::set_allocated_creator_uuid(::std::string* creator_uuid) {
  if (creator_uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete creator_uuid_;
  }
  if (creator_uuid) {
    set_has_creator_uuid();
    creator_uuid_ = creator_uuid;
  } else {
    clear_has_creator_uuid();
    creator_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes groupid = 2;
inline bool RoomInfo::has_groupid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomInfo::set_has_groupid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomInfo::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomInfo::clear_groupid() {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    groupid_->clear();
  }
  clear_has_groupid();
}
inline const ::std::string& RoomInfo::groupid() const {
  return *groupid_;
}
inline void RoomInfo::set_groupid(const ::std::string& value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void RoomInfo::set_groupid(const char* value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void RoomInfo::set_groupid(const void* value, size_t size) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomInfo::mutable_groupid() {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  return groupid_;
}
inline ::std::string* RoomInfo::release_groupid() {
  clear_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupid_;
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomInfo::set_allocated_groupid(::std::string* groupid) {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    delete groupid_;
  }
  if (groupid) {
    set_has_groupid();
    groupid_ = groupid;
  } else {
    clear_has_groupid();
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 createtime = 3;
inline bool RoomInfo::has_createtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomInfo::set_has_createtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomInfo::clear_has_createtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomInfo::clear_createtime() {
  createtime_ = 0u;
  clear_has_createtime();
}
inline ::google::protobuf::uint32 RoomInfo::createtime() const {
  return createtime_;
}
inline void RoomInfo::set_createtime(::google::protobuf::uint32 value) {
  set_has_createtime();
  createtime_ = value;
}

// repeated .vipkid.UserInfo user_list = 4;
inline int RoomInfo::user_list_size() const {
  return user_list_.size();
}
inline void RoomInfo::clear_user_list() {
  user_list_.Clear();
}
inline const ::vipkid::UserInfo& RoomInfo::user_list(int index) const {
  return user_list_.Get(index);
}
inline ::vipkid::UserInfo* RoomInfo::mutable_user_list(int index) {
  return user_list_.Mutable(index);
}
inline ::vipkid::UserInfo* RoomInfo::add_user_list() {
  return user_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vipkid::UserInfo >&
RoomInfo::user_list() const {
  return user_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::vipkid::UserInfo >*
RoomInfo::mutable_user_list() {
  return &user_list_;
}

// optional uint32 ppt_page = 5;
inline bool RoomInfo::has_ppt_page() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoomInfo::set_has_ppt_page() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoomInfo::clear_has_ppt_page() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoomInfo::clear_ppt_page() {
  ppt_page_ = 0u;
  clear_has_ppt_page();
}
inline ::google::protobuf::uint32 RoomInfo::ppt_page() const {
  return ppt_page_;
}
inline void RoomInfo::set_ppt_page(::google::protobuf::uint32 value) {
  set_has_ppt_page();
  ppt_page_ = value;
}

// optional bytes board_data = 6;
inline bool RoomInfo::has_board_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RoomInfo::set_has_board_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RoomInfo::clear_has_board_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RoomInfo::clear_board_data() {
  if (board_data_ != &::google::protobuf::internal::kEmptyString) {
    board_data_->clear();
  }
  clear_has_board_data();
}
inline const ::std::string& RoomInfo::board_data() const {
  return *board_data_;
}
inline void RoomInfo::set_board_data(const ::std::string& value) {
  set_has_board_data();
  if (board_data_ == &::google::protobuf::internal::kEmptyString) {
    board_data_ = new ::std::string;
  }
  board_data_->assign(value);
}
inline void RoomInfo::set_board_data(const char* value) {
  set_has_board_data();
  if (board_data_ == &::google::protobuf::internal::kEmptyString) {
    board_data_ = new ::std::string;
  }
  board_data_->assign(value);
}
inline void RoomInfo::set_board_data(const void* value, size_t size) {
  set_has_board_data();
  if (board_data_ == &::google::protobuf::internal::kEmptyString) {
    board_data_ = new ::std::string;
  }
  board_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomInfo::mutable_board_data() {
  set_has_board_data();
  if (board_data_ == &::google::protobuf::internal::kEmptyString) {
    board_data_ = new ::std::string;
  }
  return board_data_;
}
inline ::std::string* RoomInfo::release_board_data() {
  clear_has_board_data();
  if (board_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = board_data_;
    board_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomInfo::set_allocated_board_data(::std::string* board_data) {
  if (board_data_ != &::google::protobuf::internal::kEmptyString) {
    delete board_data_;
  }
  if (board_data) {
    set_has_board_data();
    board_data_ = board_data;
  } else {
    clear_has_board_data();
    board_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 user_num = 7;
inline bool RoomInfo::has_user_num() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RoomInfo::set_has_user_num() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RoomInfo::clear_has_user_num() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RoomInfo::clear_user_num() {
  user_num_ = 0u;
  clear_has_user_num();
}
inline ::google::protobuf::uint32 RoomInfo::user_num() const {
  return user_num_;
}
inline void RoomInfo::set_user_num(::google::protobuf::uint32 value) {
  set_has_user_num();
  user_num_ = value;
}

// -------------------------------------------------------------------

// GetRoomInfo

// optional bytes uuid = 1;
inline bool GetRoomInfo::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetRoomInfo::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetRoomInfo::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetRoomInfo::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& GetRoomInfo::uuid() const {
  return *uuid_;
}
inline void GetRoomInfo::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void GetRoomInfo::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void GetRoomInfo::set_uuid(const void* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetRoomInfo::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* GetRoomInfo::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetRoomInfo::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes groupid = 2;
inline bool GetRoomInfo::has_groupid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetRoomInfo::set_has_groupid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetRoomInfo::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetRoomInfo::clear_groupid() {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    groupid_->clear();
  }
  clear_has_groupid();
}
inline const ::std::string& GetRoomInfo::groupid() const {
  return *groupid_;
}
inline void GetRoomInfo::set_groupid(const ::std::string& value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void GetRoomInfo::set_groupid(const char* value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void GetRoomInfo::set_groupid(const void* value, size_t size) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetRoomInfo::mutable_groupid() {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  return groupid_;
}
inline ::std::string* GetRoomInfo::release_groupid() {
  clear_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupid_;
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetRoomInfo::set_allocated_groupid(::std::string* groupid) {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    delete groupid_;
  }
  if (groupid) {
    set_has_groupid();
    groupid_ = groupid;
  } else {
    clear_has_groupid();
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetRoomInfoRsp

// optional uint32 result = 1;
inline bool GetRoomInfoRsp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetRoomInfoRsp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetRoomInfoRsp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetRoomInfoRsp::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 GetRoomInfoRsp::result() const {
  return result_;
}
inline void GetRoomInfoRsp::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
}

// optional .vipkid.RoomInfo info = 2;
inline bool GetRoomInfoRsp::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetRoomInfoRsp::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetRoomInfoRsp::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetRoomInfoRsp::clear_info() {
  if (info_ != NULL) info_->::vipkid::RoomInfo::Clear();
  clear_has_info();
}
inline const ::vipkid::RoomInfo& GetRoomInfoRsp::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::vipkid::RoomInfo* GetRoomInfoRsp::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::vipkid::RoomInfo;
  return info_;
}
inline ::vipkid::RoomInfo* GetRoomInfoRsp::release_info() {
  clear_has_info();
  ::vipkid::RoomInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void GetRoomInfoRsp::set_allocated_info(::vipkid::RoomInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// -------------------------------------------------------------------

// GetRoomList

// optional bytes uuid = 1;
inline bool GetRoomList::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetRoomList::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetRoomList::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetRoomList::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& GetRoomList::uuid() const {
  return *uuid_;
}
inline void GetRoomList::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void GetRoomList::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void GetRoomList::set_uuid(const void* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetRoomList::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* GetRoomList::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetRoomList::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetRoomListRsp

// optional uint32 result = 1;
inline bool GetRoomListRsp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetRoomListRsp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetRoomListRsp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetRoomListRsp::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 GetRoomListRsp::result() const {
  return result_;
}
inline void GetRoomListRsp::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
}

// repeated .vipkid.RoomInfo list = 2;
inline int GetRoomListRsp::list_size() const {
  return list_.size();
}
inline void GetRoomListRsp::clear_list() {
  list_.Clear();
}
inline const ::vipkid::RoomInfo& GetRoomListRsp::list(int index) const {
  return list_.Get(index);
}
inline ::vipkid::RoomInfo* GetRoomListRsp::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::vipkid::RoomInfo* GetRoomListRsp::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vipkid::RoomInfo >&
GetRoomListRsp::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::vipkid::RoomInfo >*
GetRoomListRsp::mutable_list() {
  return &list_;
}

// -------------------------------------------------------------------

// KeepAlive

// optional bytes uuid = 1;
inline bool KeepAlive::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeepAlive::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeepAlive::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeepAlive::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& KeepAlive::uuid() const {
  return *uuid_;
}
inline void KeepAlive::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void KeepAlive::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void KeepAlive::set_uuid(const void* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeepAlive::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* KeepAlive::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KeepAlive::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes groupid = 2;
inline bool KeepAlive::has_groupid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeepAlive::set_has_groupid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeepAlive::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeepAlive::clear_groupid() {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    groupid_->clear();
  }
  clear_has_groupid();
}
inline const ::std::string& KeepAlive::groupid() const {
  return *groupid_;
}
inline void KeepAlive::set_groupid(const ::std::string& value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void KeepAlive::set_groupid(const char* value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void KeepAlive::set_groupid(const void* value, size_t size) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeepAlive::mutable_groupid() {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  return groupid_;
}
inline ::std::string* KeepAlive::release_groupid() {
  clear_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupid_;
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KeepAlive::set_allocated_groupid(::std::string* groupid) {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    delete groupid_;
  }
  if (groupid) {
    set_has_groupid();
    groupid_ = groupid;
  } else {
    clear_has_groupid();
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UniCast

// optional bytes uuid = 1;
inline bool UniCast::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UniCast::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UniCast::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UniCast::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& UniCast::uuid() const {
  return *uuid_;
}
inline void UniCast::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void UniCast::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void UniCast::set_uuid(const void* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UniCast::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* UniCast::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UniCast::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes groupid = 2;
inline bool UniCast::has_groupid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UniCast::set_has_groupid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UniCast::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UniCast::clear_groupid() {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    groupid_->clear();
  }
  clear_has_groupid();
}
inline const ::std::string& UniCast::groupid() const {
  return *groupid_;
}
inline void UniCast::set_groupid(const ::std::string& value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void UniCast::set_groupid(const char* value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void UniCast::set_groupid(const void* value, size_t size) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UniCast::mutable_groupid() {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  return groupid_;
}
inline ::std::string* UniCast::release_groupid() {
  clear_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupid_;
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UniCast::set_allocated_groupid(::std::string* groupid) {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    delete groupid_;
  }
  if (groupid) {
    set_has_groupid();
    groupid_ = groupid;
  } else {
    clear_has_groupid();
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes to_uuid = 3;
inline bool UniCast::has_to_uuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UniCast::set_has_to_uuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UniCast::clear_has_to_uuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UniCast::clear_to_uuid() {
  if (to_uuid_ != &::google::protobuf::internal::kEmptyString) {
    to_uuid_->clear();
  }
  clear_has_to_uuid();
}
inline const ::std::string& UniCast::to_uuid() const {
  return *to_uuid_;
}
inline void UniCast::set_to_uuid(const ::std::string& value) {
  set_has_to_uuid();
  if (to_uuid_ == &::google::protobuf::internal::kEmptyString) {
    to_uuid_ = new ::std::string;
  }
  to_uuid_->assign(value);
}
inline void UniCast::set_to_uuid(const char* value) {
  set_has_to_uuid();
  if (to_uuid_ == &::google::protobuf::internal::kEmptyString) {
    to_uuid_ = new ::std::string;
  }
  to_uuid_->assign(value);
}
inline void UniCast::set_to_uuid(const void* value, size_t size) {
  set_has_to_uuid();
  if (to_uuid_ == &::google::protobuf::internal::kEmptyString) {
    to_uuid_ = new ::std::string;
  }
  to_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UniCast::mutable_to_uuid() {
  set_has_to_uuid();
  if (to_uuid_ == &::google::protobuf::internal::kEmptyString) {
    to_uuid_ = new ::std::string;
  }
  return to_uuid_;
}
inline ::std::string* UniCast::release_to_uuid() {
  clear_has_to_uuid();
  if (to_uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = to_uuid_;
    to_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UniCast::set_allocated_to_uuid(::std::string* to_uuid) {
  if (to_uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete to_uuid_;
  }
  if (to_uuid) {
    set_has_to_uuid();
    to_uuid_ = to_uuid;
  } else {
    clear_has_to_uuid();
    to_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes msg = 4;
inline bool UniCast::has_msg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UniCast::set_has_msg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UniCast::clear_has_msg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UniCast::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& UniCast::msg() const {
  return *msg_;
}
inline void UniCast::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void UniCast::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void UniCast::set_msg(const void* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UniCast::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* UniCast::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UniCast::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes nick = 5;
inline bool UniCast::has_nick() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UniCast::set_has_nick() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UniCast::clear_has_nick() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UniCast::clear_nick() {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    nick_->clear();
  }
  clear_has_nick();
}
inline const ::std::string& UniCast::nick() const {
  return *nick_;
}
inline void UniCast::set_nick(const ::std::string& value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void UniCast::set_nick(const char* value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void UniCast::set_nick(const void* value, size_t size) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UniCast::mutable_nick() {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  return nick_;
}
inline ::std::string* UniCast::release_nick() {
  clear_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_;
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UniCast::set_allocated_nick(::std::string* nick) {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_;
  }
  if (nick) {
    set_has_nick();
    nick_ = nick;
  } else {
    clear_has_nick();
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vipkid

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vipkid::BroadCastMessageType>() {
  return ::vipkid::BroadCastMessageType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_common_2eproto__INCLUDED
